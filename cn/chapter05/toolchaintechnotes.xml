<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>工具链技术注解</title>

  <para>本节解释一些总体构建方法的基本原理和技术细节。没有必要立刻理解其中的
  所有内容。大部分信息会在实际的构建操作后更加清晰，在此过程中可以随时查阅本
  节。</para>

  <para><xref linkend="chapter-temporary-tools"/>的总体目标是要构建一个临时的
  区域，这个区域包含一些好的、可以从宿主机分离的工具集。通过使用
  <command>chroot</command>命令，本章余下的命令都将被限制在该环境中，确保了目
  标LFS系统的构建干净且没有问题。构建过程已经被设计得在让新读者承担最小风险的
  同时提供最大有教育价值的信息。</para>

  <note>
    <para>在继续之前，请注意工作平台的名称，通常也被称作目标三联字串。一个简单的
    获取目标三联字串的方法是运行源码包中的<command>config.guess</command>脚本，
    解压Binutils的源码并且运行脚本:<userinput>./config.guess</userinput>，注意输
    出结果。例如，一个现代的32位因特尔处理器的输出会是
    <emphasis>i686-pc-linux-gnu</emphasis>。</para>

    <para>同时也要注意平台的动态链接器名称，通常也被称作动态加载器(以防与Binutils
    中的<command>ld</command>混淆)。Glibc提供的动态链接器搜寻并加载一个程序所需要
    的共享库，准备运行程序然后运行程序。一个32位因特尔机器的动态链接器名称会是:
    <filename class="libraryfile">ld-linux.so.2</filename>。一个万无一失的确定动态
    链接器的方法是通过运行
    <userinput>readelf -l &lt;name of binary&gt; | grep interpreter</userinput>来
    查看宿主机上任何一个二进制可执行文件并注意输出结果。官方的参考覆盖了所有平台，
    它位于Glibc源码树根目录下的<filename>shlib-versions</filename>文件中。</para>
  </note>

  <para>有关<xref linkend="chapter-temporary-tools"/>中的构建方法的一些核心技术细
  节如下:</para>

  <itemizedlist>
    <listitem>
      <para>Slightly adjusting the name of the working platform, by changing the
      &quot;vendor&quot; field target triplet by way of the
      <envar>LFS_TGT</envar> variable, ensures that the first build of Binutils
      and GCC produces a compatible cross-linker and cross-compiler. Instead of
      producing binaries for another architecture, the cross-linker and
      cross-compiler will produce binaries compatible with the current
      hardware.</para>
    </listitem>
    <listitem>
      <para> The temporary libraries are cross-compiled.  Because a
      cross-compiler by its nature cannot rely on anything from its host
      system, this method removes potential contamination of the target
      system by lessening the chance of headers or libraries from the host
      being incorporated into the new tools.  Cross-compilation also allows for
      the possibility of building both 32-bit and 64-bit libraries on 64-bit
      capable hardware.</para>
    </listitem>
    <listitem>
    <para>Careful manipulation of the GCC source tells the compiler which target
    dynamic linker will be used.</para>
    </listitem>
  </itemizedlist>

  <para>Binutils is installed first because the <command>configure</command>
  runs of both GCC and Glibc perform various feature tests on the assembler
  and linker to determine which software features to enable or disable. This
  is more important than one might first realize. An incorrectly configured
  GCC or Glibc can result in a subtly broken toolchain, where the impact of
  such breakage might not show up until near the end of the build of an
  entire distribution. A test suite failure will usually highlight this error
  before too much additional work is performed.</para>

  <para>Binutils installs its assembler and linker in two locations,
  <filename class="directory">/tools/bin</filename> and <filename
  class="directory">/tools/$LFS_TGT/bin</filename>. The tools in one
  location are hard linked to the other. An important facet of the linker is
  its library search order. Detailed information can be obtained from
  <command>ld</command> by passing it the <parameter>--verbose</parameter>
  flag. For example, an <userinput>ld --verbose | grep SEARCH</userinput>
  will illustrate the current search paths and their order. It shows which
  files are linked by <command>ld</command> by compiling a dummy program and
  passing the <parameter>--verbose</parameter> switch to the linker. For example,
  <userinput>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</userinput>
  will show all the files successfully opened during the linking.</para>

  <para>The next package installed is GCC. An example of what can be
  seen during its run of <command>configure</command> is:</para>

<screen><computeroutput>checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

  <para>This is important for the reasons mentioned above. It also demonstrates
  that GCC's configure script does not search the PATH directories to find which
  tools to use. However, during the actual operation of <command>gcc</command>
  itself, the same search paths are not necessarily used. To find out which
  standard linker <command>gcc</command> will use, run:
  <userinput>gcc -print-prog-name=ld</userinput>.</para>

  <para>Detailed information can be obtained from <command>gcc</command> by
  passing it the <parameter>-v</parameter> command line option while compiling
  a dummy program. For example, <userinput>gcc -v dummy.c</userinput> will show
  detailed information about the preprocessor, compilation, and assembly stages,
  including <command>gcc</command>'s included search paths and their order.</para>

  <para>Next installed are sanitized Linux API headers. These allow the standard
  C library (Glibc) to interface with features that the Linux kernel will
  provide.</para>

  <para>The next package installed is Glibc. The most important considerations
  for building Glibc are the compiler, binary tools, and kernel headers. The
  compiler is generally not an issue since Glibc will always use the compiler
  relating to the <parameter>--host</parameter> parameter passed to its
  configure script, e.g. in our case,
  <command>i686-lfs-linux-gnu-gcc</command>. The binary tools and kernel
  headers can be a bit more complicated. Therefore, take no risks and use the
  available configure switches to enforce the correct selections. After the run
  of <command>configure</command>, check the contents of the
  <filename>config.make</filename> file in the <filename
  class="directory">glibc-build</filename> directory for all important details.
  Note the use of <parameter>CC="i686-lfs-gnu-gcc"</parameter> to control which
  binary tools are used and the use of the <parameter>-nostdinc</parameter> and
  <parameter>-isystem</parameter> flags to control the compiler's include
  search path. These items highlight an important aspect of the Glibc
  package&mdash;it is very self-sufficient in terms of its build machinery and
  generally does not rely on toolchain defaults.</para>

  <para>During the second pass of Binutils, we are able to utilize the
  <parameter>--with-lib-path</parameter> configure switch to control
  <command>ld</command>'s library search path.</para>

  <para>For the second pass of GCC, its sources also need to be modified to
  tell GCC to use the new dynamic linker. Failure to do so will result in the
  GCC programs themselves having the name of the dynamic linker from the host
  system's <filename class="directory">/lib</filename> directory embedded into
  them, which would defeat the goal of getting away from the host. From this
  point onwards, the core toolchain is self-contained and self-hosted. The
  remainder of the <xref linkend="chapter-temporary-tools"/> packages all build
  against the new Glibc in <filename
  class="directory">/tools</filename>.</para>

  <para>Upon entering the chroot environment in <xref
  linkend="chapter-building-system"/>, the first major package to be
  installed is Glibc, due to its self-sufficient nature mentioned above.
  Once this Glibc is installed into <filename
  class="directory">/usr</filename>, we will perform a quick changeover of the
  toolchain defaults, and then proceed in building the rest of the target
  LFS system.</para>

</sect1>
