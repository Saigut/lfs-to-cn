<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-toolchaintechnotes">
  <?dbhtml filename="toolchaintechnotes.html"?>

  <title>工具链技术注解</title>

  <para>本节解释一些总体构建方法的基本原理和技术细节。没有必要立刻理解其中的所有内容。大部分信息会在实际的构建操作后更加清晰，在此过程中可以随时查阅本节。</para>

  <para><xref linkend="chapter-temporary-tools"/>的总体目标是要构建一个临时的区域，这个区域包含一些好的、可以从宿主机分离的工具集。通过使用 <command>chroot</command> 命令，本章余下的命令都将被限制在该环境中，确保了目标LFS系统的构建干净且没有问题。构建过程已经被设计得在让新读者承担最小风险的同时提供最大有教育价值的信息。</para>

  <note>
    <para>在继续之前，请注意工作平台的名称，通常也被称作目标三联字串。一个简单的获取目标三联字串的方法是运行源码包中的 <command>config.guess</command> 脚本，解压Binutils的源码并且运行脚本: <userinput>./config.guess</userinput> ，注意输出结果。例如，一个现代的32位因特尔处理器的输出会是 <emphasis>i686-pc-linux-gnu</emphasis> 。</para>

    <para>同时也要注意平台的动态链接器名称，通常也被称作动态加载器(以防与Binutils中的 <command>ld</command> 混淆)。Glibc提供的动态链接器搜寻并加载一个程序所需要的共享库，准备运行程序然后运行程序。一个32位因特尔机器的动态链接器名称会是: <filename class="libraryfile">ld-linux.so.2</filename> 。一个万无一失的确定动态链接器的方法是通过运行 <userinput>readelf -l &lt;name of binary&gt; | grep interpreter</userinput> 来查看宿主机上任何一个二进制可执行文件并注意输出结果。官方的参考覆盖了所有平台，它位于Glibc源码树根目录下的 <filename>shlib-versions</filename> 文件中。</para>
  </note>

  <para>有关<xref linkend="chapter-temporary-tools"/>中的构建方法的一些核心技术细节如下:</para>

  <itemizedlist>
    <listitem>
      <para>轻微地调整工作平台的名字，改变 <envar>LFS_TGT</envar> 变量来改变三联字串中的&quot;生产商&quot;，以确保首次构建的Binutils和GCC的产生兼容的交叉链接器和交叉编译器。交叉链接器和交叉编译器将产生兼容当前硬件的二进制文件而不是兼容另一个构架的二进制文件。</para>
    </listitem>
    <listitem>
      <para>临时的库是交叉编译的。因为交叉编译器自然不能依赖宿主系统上的任何东西，所以这种方式减小了宿主机上的头文件和库被新工具包含的可能，从而避免了目标系统可能受到的污染。交叉编译也允许在64位兼容的硬件上既构建32位的库也构建64位的库。</para>
    </listitem>
    <listitem>
    <para>谨慎地对GCC源码进行的操作告诉了编译器该使用哪个动态链接器。</para>
    </listitem>
  </itemizedlist>

  <para>Binutils首先被安装，因为运行GCC和Glibc的 <command>configure</command> 命令会对汇编器和链接器进行不同的特性测试来决定哪些软件特性会被启用，哪些会被禁用。这比你一开始就意识到的要重要。一个不正确的GCC或Glibc的配置可能会导致工具链细小的破损，这个破损所产生的影响可能会到构建整个发行版的过程快结束时才显现出来。在许多额外工作进行前，一个测试套件的失败通常会指出这个错误。</para>

  <para>Binutils把它的汇编器和链接器安装在两个位置: <filename class="directory">/tools/bin</filename> 和 <filename class="directory">/tools/$LFS_TGT/bin</filename> 。两个位置间的工具是硬链接。链接器很重要的一点是它搜索库的顺序。可以通过传递 <parameter>--verbose</parameter> 参数给 <command>ld</command> 获取详细信息。例如，<userinput>ld --verbose | grep SEARCH</userinput> 将会按顺序列出当前的搜索路径。通过编译一个伪程序并传递 <parameter>--verbose</parameter> 参数给链接器可以显示哪些文件被 <command>ld</command> 链接。例如 <userinput>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</userinput> 会显示链接过程中所有被成功打开的文件。</para>

  <para>下一个被安装的软件包是GCC。在运行 <command>configure</command> 命令过程中能看到的输出的一例为:</para>

<screen><computeroutput>checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</computeroutput></screen>

  <para>This is important for the reasons mentioned above. It also demonstrates
  that GCC's configure script does not search the PATH directories to find which
  tools to use. However, during the actual operation of <command>gcc</command>
  itself, the same search paths are not necessarily used. To find out which
  standard linker <command>gcc</command> will use, run:
  <userinput>gcc -print-prog-name=ld</userinput>.</para>

  <para>Detailed information can be obtained from <command>gcc</command> by
  passing it the <parameter>-v</parameter> command line option while compiling
  a dummy program. For example, <userinput>gcc -v dummy.c</userinput> will show
  detailed information about the preprocessor, compilation, and assembly stages,
  including <command>gcc</command>'s included search paths and their order.</para>

  <para>Next installed are sanitized Linux API headers. These allow the standard
  C library (Glibc) to interface with features that the Linux kernel will
  provide.</para>

  <para>The next package installed is Glibc. The most important considerations
  for building Glibc are the compiler, binary tools, and kernel headers. The
  compiler is generally not an issue since Glibc will always use the compiler
  relating to the <parameter>--host</parameter> parameter passed to its
  configure script, e.g. in our case,
  <command>i686-lfs-linux-gnu-gcc</command>. The binary tools and kernel
  headers can be a bit more complicated. Therefore, take no risks and use the
  available configure switches to enforce the correct selections. After the run
  of <command>configure</command>, check the contents of the
  <filename>config.make</filename> file in the <filename
  class="directory">glibc-build</filename> directory for all important details.
  Note the use of <parameter>CC="i686-lfs-gnu-gcc"</parameter> to control which
  binary tools are used and the use of the <parameter>-nostdinc</parameter> and
  <parameter>-isystem</parameter> flags to control the compiler's include
  search path. These items highlight an important aspect of the Glibc
  package&mdash;it is very self-sufficient in terms of its build machinery and
  generally does not rely on toolchain defaults.</para>

  <para>During the second pass of Binutils, we are able to utilize the
  <parameter>--with-lib-path</parameter> configure switch to control
  <command>ld</command>'s library search path.</para>

  <para>For the second pass of GCC, its sources also need to be modified to
  tell GCC to use the new dynamic linker. Failure to do so will result in the
  GCC programs themselves having the name of the dynamic linker from the host
  system's <filename class="directory">/lib</filename> directory embedded into
  them, which would defeat the goal of getting away from the host. From this
  point onwards, the core toolchain is self-contained and self-hosted. The
  remainder of the <xref linkend="chapter-temporary-tools"/> packages all build
  against the new Glibc in <filename
  class="directory">/tools</filename>.</para>

  <para>Upon entering the chroot environment in <xref
  linkend="chapter-building-system"/>, the first major package to be
  installed is Glibc, due to its self-sufficient nature mentioned above.
  Once this Glibc is installed into <filename
  class="directory">/usr</filename>, we will perform a quick changeover of the
  toolchain defaults, and then proceed in building the rest of the target
  LFS system.</para>

</sect1>
